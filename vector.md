# vector的定义和原理和与vector的相关操作

## 目录
- [1. 实现原理](#1-实现原理)  
  - [1.1 新增元素](#11-新增元素)


## 1 实现原理
C++中的vector本质上是一个动态数组（vector的底层实现原理为一维数组），它的元素是连续存储的，这意味着不仅可以通过迭代器访问元素，还可以使用指向元素的常规指针来对其进行访问。  
从实现原理来看：vector的随机访问是比较高效的, ( 可以直接使用数组下标的方式：vector[ i ] ）;
### 1.1 新增元素
插入vector中的新元素一般可以通过push_back()方法放入vector的末尾或者通过迭代器在vector的任何位置插入；  
对于迭代器的插入，首先是通过迭代器与第一个元素的距离知道要插入的位置，即int index = iter-vector.begin()，这个元素之后的所有元素都要向后移动一个位置，在空出来的位置上存入新增的元素

### *需要注意的点：*  
这里就会涉及到一个问题：既然vector是动态增长的，那么当其空间用完了的时候，基于vector连续存储的特性，要怎样处理空间不足的问题呢？  

STL中vector使用的策略便是:预先分配策略----这样可以有效的减少空间的分配次数  
vector会先分配一个比需求更大的空间作为预留， 

这里便涉及到vector的几个属性：  
size():表示当前vector中已有的元素数量；  
capacity():表示vector的实际总容量，即预留空间大小
reserver():表示要求vector的容量是多少，如果大于capacity则vector需要扩容  

举个例子：  
当vector的size大小为50时，这是capacity也为50的话，那么再新增一个元素的时候就需要对capacity进行扩容，变为100,而size加1即可；  
这里需要注意的是：  
只有在迫不得已的时候，才可以重新分配内存空间
vector扩容的时候为了保证其连续性，是去开辟新的更大的连续空间，再把vector中原来的元素移动到新空间，最后释放旧空间  
capcaity的具体扩容策略由标准库决定，（以等长方式扩容，以倍数（1.5或者2）方式扩容） *[ ps:具体的扩容方式和原因本人还没有理清楚，暂时不分析 ]*  


## push_back() 和 emplace_back() 的区别

一句话概括：  
push_back()是构造了新元素之后，拷贝到容器的末尾；而emplace_back()则是直接构造了新元素并将它添加到容器的末尾，省略了拷贝构造这一操作。  

