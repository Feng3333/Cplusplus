# 运算符重载
运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

# 目录
 - [加号运算符重载](#加号运算符重载)
 - [左移运算符重载](#左移运算符重载)
 - [递增运算符重载](#递增运算符重载)
 
# 加号运算符重载
作用：实现两个自定义数据类型相加的运算
```cpp
#include <iostream>
#include <string>

#ifndef TEST_H
#define TEST_H

class Person {
public:
    Person(){};
    Person(int a, int b) {
        this->mA_ = a;
        this->mB_ = b;
    }

    // 成员函数实现 + 号运算符重载
    Person operator+(const Person& p) {
        Person temp;
        temp.mA_ = this->mA_ + p.mA_;
        temp.mB_ = this->mB_ + p.mB_;
        return temp;
    }

public: 
    int mA_;
    int mB_;
};

// 全局变量实现 + 号运算符重载
// Person operator+(const Person& p1, const Person& p2) {
//     Person temp(0, 0);
//     temp.mA_ = p1.mA_ + p2.mA_;
//     temp.mB_ = p1.mA_ + p2.mB_;
//     return temp;
// }

// 运算符重载，可以发生函数重载
Person operator+(const Person& p2, int val) {
    Person temp;
    temp.mA_ = p2.mA_ + val;
    temp.mB_ = p2.mA_ + val;
    return temp;
}

#endif // TEST_H
```
```cpp
#include "test.h"

int main()
{
    Person p1(10, 10);
    Person p2(20, 20);

    Person p3 = p1 + p2;
    std::cout << "p3.mA_ : " << p3.mA_ << "  p3.mB_ : " << p3.mB_ << std::endl;

    Person p4 = p3 + 5;
    std::cout << "p4.mA_ : " << p4.mA_ << "  p4.mB_ : " << p4.mB_ << std::endl;
    return 0;
}
```

# 左移运算符重载
作用：可以输出自定义数据类型  
需要注意的是：重载左移运算符配合友元可以实现输出自定义数据类型，  

代码示例：  
```cpp
// #include "test.h"
#include <iostream>
#include <string>

class Num {
    friend std::ostream& operator<<(std::ostream& out, Num& p);

public:
    Num(int a, int b) {
        this->mA_ = a;
        this->mB_ = b;
    };

private:
    int mA_;
    int mB_;
};

// 全局函数实现左移运算符重载，ostream对象只能有一个
std::ostream& operator<<(std::ostream& out, Num& p) {
    out << "a: " << p.mA_ << " b: " << p.mB_;
    return out;
}

int main()
{
    Num num(10, 20);
    std::cout << num << " finish " << std::endl;
    return 0;
}
```

# 递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据  
- 加上&可以在原来的对象上操作，不加&符号的话会返回一个新的对象  

代码示例：
```cpp
// #include "test.h"
#include <iostream>
#include <string>

class MyInteger {
    friend std::ostream& operator<<(std::ostream& out, MyInteger myInt);
public:
    MyInteger() {
        num_ = 0;
    }
    
    // 前置++
    MyInteger& operator++() {
        num_++;
        return *this;
    }

    // 后置++
    MyInteger operator++(int) {
        // 记录当前本身的值，然后本身的值在加1，但是返回以前的值，
        MyInteger temp = *this;
        num_++;
        return temp;
    }

private:
    int num_;
};

std::ostream& operator<<(std::ostream& out, MyInteger myInt) {
    out << myInt.num_;
    return out;
}

int main()
{
    MyInteger myInt;
    std::cout << myInt++ << std::endl;
    std::cout << myInt << std::endl;
    std::cout << ++myInt << std::endl;
    std::cout << myInt << std::endl;
    return 0;
}
```
上述代码中：前置递增返回引用，后置递增返回的是值（新的对象）

