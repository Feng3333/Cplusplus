# C++ 中的static
C++中的static主要有两种用法: 面向过程程序设计中的static 和 面向对象程序设计中的static. 前者应用于普通变量和函数,不涉及类; 后者主要说明static在类中的作用. 
## 目录
- [1. 面向过程程序设计中的static](#1-面向过程程序设计中的static)
  - [1.1 静态全局变量](#11-静态全局变量)
  - [1.2 静态局部变量](#12-静态局部变量)
  - [1.3 静态函数](#13-静态函数)
- [2. 面向对象程序设计中的static](#2-面向对象程序设计中的static)
  - [2.1 静态数据成员](#21-静态数据成员)
  - [2.1 静态成员函数](#22-静态成员函数)

## 1. 面向过程程序设计中的static
### 1.1 静态全局变量
在全局变量前, 加上关键字static, 该变量便被定义为静态全局变量  
简单举例:  
```c++
#include <iostream>

static int num; //静态全局变量

void fn()
{
    num++;
    std::cout << "num : " << num << std::endl;
}

int main() {
    num = 20;
    std::cout << "num : " << num << std::endl;
    fn();
    return 0;
}
```
静态全局变量具有以下特点: 
- 该变量在全局数据区分配内存;
- 未经初始化的静态全局变量会被程序自动初始化为0 (自动变量的值是随机的, 除非它被显示初始化);
- 静态全局变量在声明它的整个文件都是可见的, 而在文件之外是不可见的;

静态全局变量的优点:  
- a. 静态全局变量不能被其他文件所用
- b. 其他文件中可以定义相同名字的变量, 不会发生冲突;

### 1.2 静态局部变量
在局部变量前, 加上关键字static, 该变量便被定义为静态局部变量.  
简单举例: 
```c++
#include <iostream>

void fn()
{
    static int num = 0;
    std::cout << "num : " <<num++ << std::endl;
}

int main() {
    for (size_t i = 0; i < 3; ++i) {
        fn();
    }
    return 0;
}
```
通常, 在函数体内定义了一个变量, 每当程序运行到该函数时都会给该局部变量分配栈内存. 随着程序推出函数体, 系统就会收回栈内存, 局部变量也将相应失效. 但有时候需要在两次调用该函数之间对变量的值进行保存. 如果使用全局变量来实现则该全局变量不再属于函数本身了, 不仅有可能不受该函数控制, 而且给程序的维护带来不便;  
静态局部变量则可以解决上述问题, 由于静态局部变量保存在全局数据区中, 每次的值保持到下一次的调用, 直到下次赋新值.  


静态局部变量有以下特点:  
- 该变量在全局数据区分配内存;  
- 静态局部变量在程序执行带该对象的声明处被首次初始化, 即以后的函数调用不再进行初始化;  
- 静态局部变量一般在声明处初始化, 如果没有被显示初始化, 会被程序自动初始化为0; 
- 静态局部变量始终驻留在全局数据区, 直到程序运行结束. 但其作用域为局部作用域, 当定义它的函数或语句块结束时, 其作用域也随之结束;  

### 1.3 静态函数
在函数的返回类型前面加上static关键字后, 该函数则被定义为静态函数;  
静态函数与普通函数不同, 它只能在声明它的头文件中可见, 不能被其他文件使用;  
简单举例: 
```c++
#include <iostream>

static void fn(); //声明为静态函数

int main() {
    fn();
    return 0;
}

void fn() //定义该函数
{
    int num = 10;
    std::cout << "num : " << num << std::endl;
}
```
静态函数的特点: 
- 静态函数不能被其他文件使用;  
- 其他文件中可以定义相同名字的函数, 不会发生冲突;  

## 2. 面向对象程序设计中的static

- 这里主要指类中的static关键字


### 2.1 静态数据成员

在类中数据成员的声明前加上static关键字, 该数据成员就是类中的静态数据成员;  
简单举例:  
```c++
#include <iostream>

class Myclass
{
public:
    Myclass(int a, int b, int c){
        this->a = a;
        this->b = b;
        this->c = c;
        sum += a + b + c;
    };

    void GetSum(){
        std::cout << "sum = " << sum << std::endl;
    }

private:
    int a, b, c;
    static int sum; // 声明为静态数据成员
};
int Myclass::sum = 0; // 定义并初始化静态函数成员

int main() {
    Myclass my1(1, 1, 1);
    my1.GetSum();
    Myclass my2(2, 2, 2);
    my2.GetSum();
    my1.GetSum();
    return 0;
}
```
上述代码的运行结果为:  
```
sum = 3
sum = 9
sum = 9
```
静态数据成员的特点:  
- a. 对于非静态数据成员, 每个类对象都有自己拷贝. 而静态数据成员被当做是类的成员, 无论这个类的对象被定义了多少个, 静态数据成员在程序中也只是拷贝了一份, 并且由该类型的所有对象共享访问; 也就是说, 静态数据成员是该类的所有对象所共有的; 对该类的多个对象来说, 静态数据成员值分配一次内存, 供所有对象共用; 所以, 静态数据成员的值对于每一个对象都是一样的, 它的值可以更新.
- b. 静态数据成员存储在全局数据区, 静态数据成员定义的时候就要分配空间, 所以不能在类中声明定义, 在上述例子中, int Myclass::sum = 0 就是定义静态数据成员.  
- c. 静态数据成员和普通数据成员遵循一样的 public, private, protected 访问规则.  
- d. 因为静态数据成员在全局数据区分享内存, 属于本类的所有对象共享, 所以它不属于特定的类对象, 在没有产生类对象时其作用域就可见, 即在没有产生类的实例时, 就可以操作它.  
- e. 静态数据成员初始化与一般数据成员初始化不同; 静态数据成员初始化的格式为: 
```
<数据类型> <类名>::<静态数据成员名> = <值>;
```
- f. 静态数据成员的两种访问形式:  
```
<类对象名>.<静态数据成员名>;
<类类型名>::<静态数据成员名>;
```
如果静态数据成员的访问权限允许的话 (即为public的成员), 可以在程序中使用第一种访问形式来引用该静态数据成员
- g. 静态数据成员主要用在各个对象都有相同的某项属性的时候. 比如对于一个存款类, 每个实例的利息都是相同的. 所以, 应该把利息设为存款类的静态数据成员. 这有两个好处, 第一, 不管定义多少个存款类对象, 利息数据成员都共享分配在全局数据区的内存, 所以节省存储空间, 第二, 一旦利息需要改变时, 只要改变一次, 则所有存款类对象的利息全改变过来了;  
- h. 同全局变量相比, 使用静态数据成员有两个优势:  
```
h1 : 静态数据成员没有进入程序的全局名字空间, 因此不存在与程序中其他全局名字冲突的可能性;  
h2 : 可以实现信息隐藏. 静态数据成员可以是private成员, 而全局变量不行;  
```

### 2.2 静态成员函数
静态成员函数为类的全部服务而不是为某一个类的具体对象服务.   
静态成员函数与静态数据成员一样, 都是类的内部实现, 属于类定义的一部分.   
普通的成员函数一般都隐含了一个this指针, this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的. 通常情况下, this是缺省的. 如函数 fn() 实际上是 this->fn(). 
与普通函数相比, 静态成员函数由于不是与任何的对象相联系, 因此它不具有this指针. 从这个意义上讲, 它无法访问属于类对象的非静态数据成员, 也无法访问非静态成员函数, 它只能调用其余的静态成员函数.  
简单举例 ：
```c++
#include <iostream>
#include <numeric>
#include <algorithm>

class Myclass
{
public:
    Myclass(int a, int b, int c){
        this->a = a;
        this->b = b;
        this->c = c;
        sum += a + b + c;
    };

    static void GetSum(); //声明静态成员函数

private:
    int a, b, c;
    static int sum; // 声明为静态数据成员
    
};
int Myclass::sum = 0; // 定义并初始化静态函数成员

void Myclass::GetSum() //静态成员函数的实现
{
    //std::cout << a << std::endl; // error:invalid use of member ‘Myclass::a’ in static member function
    std::cout << "sum = " << sum << std::endl;
}

int main() {
    Myclass M(1, 2, 3);
    M.GetSum();
    Myclass N(4, 5, 6);
    N.GetSum();
    Myclass::GetSum();
    return 0;
}
```
上述代码的运行结果 :
```
sum = 6
sum = 21
sum = 21
```
静态成员函数的特点:
- 出现在类体外的函数定义不能指定关键字static;  
- 静态成员之间可以相互访问, 包括静态成员函数访问静态数据成员和访问静态成员函数;  
- 非静态成员函数可以任意地访问静态成员函数和静态数据成员;  
- 静态成员函数不能访问非静态成员函数和非静态数据成员;  
- 由于没有this指针的额外开销,因此静态成员函数比类的全局函数相比速度上会有少许的增长;
- 调用静态成员函数,可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数, 也可以直接使用如下格式 调用类的静态成员函数
```
<类名>::<静态成员函数名> (<参数表>)
```
- 静态成员函数的作用: 主要是为了方便, 不需要生成对象就能调用;  
