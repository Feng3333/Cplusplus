# C++ 中的static
C++中的static主要有两种用法: 面向过程程序设计中的static 和 面向对象程序设计中的static. 前者应用于普通变量和函数,不涉及类; 后者主要说明static在类中的作用. 
## 目录
- [1. 面向过程程序设计中的static](#1-面向过程程序设计中的static)
- [2. 面向对象程序设计中的static](#2-面向对象程序设计中的static)

## 1. 面向过程程序设计中的static
### 1.1 静态全局变量
在全局变量前, 加上关键字static, 该变量便被定义为静态全局变量  
简单举例:  
```c++
#include <iostream>

static int num; //静态全局变量

void fn()
{
    num++;
    std::cout << "num : " << num << std::endl;
}

int main() {
    num = 20;
    std::cout << "num : " << num << std::endl;
    fn();
    return 0;
}
```
静态全局变量具有以下特点: 
- 该变量在全局数据区分配内存;
- 未经初始化的静态全局变量会被程序自动初始化为0 (自动变量的值是随机的, 除非它被显示初始化);
- 静态全局变量在声明它的整个文件都是可见的, 而在文件之外是不可见的;

静态全局变量的优点:  
- a. 静态全局变量不能被其他文件所用
- b. 其他文件中可以定义相同名字的变量, 不会发生冲突;

### 1.2 静态局部变量
在局部变量前, 加上关键字static, 该变量便被定义为静态局部变量.  
简单举例: 
```c++
#include <iostream>

void fn()
{
    static int num = 0;
    std::cout << "num : " <<num++ << std::endl;
}

int main() {
    for (size_t i = 0; i < 3; ++i) {
        fn();
    }
    return 0;
}
```
通常, 在函数体内定义了一个变量, 每当程序运行到该函数时都会给该局部变量分配栈内存. 随着程序推出函数体, 系统就会收回栈内存, 局部变量也将相应失效. 但有时候需要在两次调用该函数之间对变量的值进行保存. 如果使用全局变量来实现则该全局变量不再属于函数本身了, 不仅有可能不受该函数控制, 而且给程序的维护带来不便;  
静态局部变量则可以解决上述问题, 由于静态局部变量保存在全局数据区中, 每次的值保持到下一次的调用, 直到下次赋新值.  


静态局部变量有以下特点:  
- 该变量在全局数据区分配内存;  
- 静态局部变量在程序执行带该对象的声明处被首次初始化, 即以后的函数调用不再进行初始化;  
- 静态局部变量一般在声明处初始化, 如果没有被显示初始化, 会被程序自动初始化为0; 
- 静态局部变量始终驻留在全局数据区, 直到程序运行结束. 但其作用域为局部作用域, 当定义它的函数或语句块结束时, 其作用域也随之结束;  


## 2. 面向对象程序设计中的static
